#include <Adafruit_NeoPixel.h>

//pin definition for LED Color Data
#define PIN 6
#define PIN2 9
#define PIN3 11
#define PIN4 13


#define EnergyRange 100  //energy range, generated by windmilss
#define EnergyAmp 2      // energy amplicatoin co-efficients. higher value leads to brigher light
#define EnergyDissipate 3  // energy dissipation co-efficients. higher value leads to fast dimming

// Parameter 1 = number of pixels in strip
// Parameter 2 = Arduino pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)
Adafruit_NeoPixel strip = Adafruit_NeoPixel(13, PIN, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel strip2 = Adafruit_NeoPixel(13, PIN2, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel strip3 = Adafruit_NeoPixel(13, PIN3, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel strip4 = Adafruit_NeoPixel(13, PIN4, NEO_GRB + NEO_KHZ800);

// IMPORTANT: To reduce NeoPixel burnout risk, add 1000 uF capacitor across
// pixel power leads, add 300 - 500 Ohm resistor on first pixel's data input
// and minimize distance between Arduino and first pixel.  Avoid connecting
// on a live circuit...if you must, connect GND first.
int stage;

/*****************WINDMILLS*******************************/
const int numMills = 3;              // How many windmills are there
const int millPins[] = {2, 3, 5};    // Which pins the windmills are attached to, given in RGB order
const int ledPins[] = {9, 10, 11};   // Which pins the LEDs are attached to, given in RGB order

unsigned long pulseCountWindowLength = 100;  // Length of time in which signal pulses are counted (in milliseconds)

int pulseCount[] = {0,0,0};             // Counter for number of pulses which occur in the pulseCountWindowLenght (for windmills in RGB order)

int millStates[] = {HIGH, HIGH, HIGH};  // Tracks the previous state for each windmill (high or low).  Used to detect pulses via state change 

unsigned long pulseCountStartTime = 0;  // Start time for each pulse count window.

// These variables are used locally below, but are declared globally to save the minor overhead necessary to create new variables (probably unnecessary
int millVal = LOW;  // The current value of a windmill
int cnt = 0;  // A loop counter

int energy[] = {0,0,0,0};

void setup()
{
  stage=0;
  strip.begin();
  strip.show(); // Initialize all pixels to 'off'
  strip2.begin();
  strip2.show(); // Initialize all pixels to 'off'
  strip3.begin();
  strip3.show(); // Initialize all pixels to 'off'
  strip4.begin();
  strip4.show(); // Initialize all pixels to 'off'
    // Setup pin modes and initialize windmill states from sensor data
    
  for(cnt=0; cnt < numMills; cnt++) {
    pinMode(millPins[cnt], INPUT); 
    //pinMode(ledPins[cnt], OUTPUT);
    millStates[cnt] = digitalRead( millPins[cnt] );
  }

  pulseCountStartTime = millis();

}

void loop() {
     
   int colorR,colorG,colorB;
  
   for(cnt = 0; cnt < numMills; cnt++) {         
        pulseCount[cnt] = 0; // reset pulse count
   }
   pulseCountStartTime = millis(); 
   pulseCountWindowLength=200;   
   while(millis() - pulseCountStartTime < pulseCountWindowLength){
    for(cnt = 0; cnt < numMills; cnt++) {
      // Read current windmill state
      millVal = digitalRead(millPins[cnt]);
    
    // If the state changed
      if ( millVal != millStates[cnt] ) {  // Check each windmill for a state change
        millStates[cnt] = millVal; // update state
        pulseCount[cnt]++; // count pulse
      }
      
    }
  
  delay(10);
   }
  
  // If we've reached the end of the pulse count window
  
 
  // measure the energy obtained from windmills
  if(energy[0]<=100) energy[0]=energy[0]+pulseCount[0]*EnergyAmp;
  if(energy[1]<=100) energy[1]=energy[1]+pulseCount[1]*EnergyAmp;
  if(energy[2]<=100) energy[2]=energy[2]+pulseCount[2]*EnergyAmp;

  // Energy dissipates over time
  if(energy[0]>=EnergyDissipate) energy[0]-=EnergyDissipate;
    else energy[0]=0;
  if(energy[1]>=EnergyDissipate) energy[1]-=EnergyDissipate;
    else energy[1]=0;
  if(energy[2]>=EnergyDissipate) energy[2]-=EnergyDissipate;
    else energy[2]=0;
  if(energy[0]>0) {
    colorR=map(energy[0],0,EnergyRange,0,255);
    if(colorR>255) colorR=255;
    colorWipe(strip.Color(colorR, colorR, 0), 5); // Red
  } else {
    colorWipe(strip.Color(0, 0, 0), 5); // Red
  }
  
  //map each energy to each LED group
  if(energy[1]>0) {
    colorR=map(energy[1],0,EnergyRange,0,200);
    if(colorR>255) colorR=255;
    colorB=map(energy[1],0,EnergyRange,0,100);
    if(colorB>255) colorB=255;
    
    colorWipe2(strip.Color(colorR, colorR, colorB), 5); // Red
  } else {
    colorWipe2(strip.Color(0, 0, 0), 5); // Red
  }
  if(energy[2]>0) {
    colorR=map(energy[2],0,EnergyRange,0,100);
    if(colorR>255) colorR=255;
    colorB=map(energy[2],0,EnergyRange,0,150);
    if(colorB>255) colorB=255;
    
    colorWipe3(strip.Color(colorR, colorB, colorB), 5); // Red
  } else {
    colorWipe3(strip.Color(0, 0, 0), 5); // Red
  }

  
  //Mixing 3 kinds of energy to generate RGB-colored LED
  colorR=map(energy[0],0,EnergyRange,0,255);
  colorG=map(energy[1],0,EnergyRange,0,255);
  colorB=map(energy[2],0,EnergyRange,0,255);
    if(colorR>255) colorR=255;
    if(colorG>255) colorG=255; 
    if(colorB>255) colorB=255;
  
    colorWipe4(strip.Color(colorR, colorG, colorB), 5); // Red
   
  stage++;
  
}

// Fill the LED dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  uint32_t voidC=strip.Color(0,0,0);
  uint32_t appC;
  for(uint16_t i=0; i<strip.numPixels(); i++) {
      if(i%2 == stage/10 % 2) appC=voidC;
        else appC=c;
      strip.setPixelColor(i, appC);
      strip.show();
      delay(wait);
  }
}
void colorWipe2(uint32_t c, uint8_t wait) {
  uint32_t voidC=strip.Color(0,0,0);
  uint32_t appC; 
  for(uint16_t i=0; i<strip2.numPixels(); i++) {
    if(i%3 == stage % 3) appC=voidC;
        else appC=c;  
      strip2.setPixelColor(i, appC);
      strip2.show();
      delay(wait);
  }
}

void colorWipe3(uint32_t c, uint8_t wait) {
   uint32_t voidC=strip.Color(0,0,0);
  uint32_t appC;
  for(uint16_t i=0; i<strip3.numPixels(); i++) {
    if(i%2 == stage % 2) appC=voidC;
        else appC=c;  
    strip3.setPixelColor(i, appC);
      strip3.show();
      delay(wait);
  }
}

void colorWipe4(uint32_t c, uint8_t wait) {
   uint32_t voidC=strip.Color(0,0,0);
  uint32_t appC;
  for(uint16_t i=0; i<strip4.numPixels(); i++) {
      if(i%2 == stage % 2) appC=voidC;
        else appC=c;
        strip4.setPixelColor(i, appC);
      strip4.show();
      delay(wait);
  }
}


